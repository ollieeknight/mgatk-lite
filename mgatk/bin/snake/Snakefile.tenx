import os
import subprocess
import shutil
import pysam
from os.path import join

# Parse the configuration variables
configfile: config["cfp"]
outdir = config["output_directory"]
mgatk_directory = outdir
name = config["name"]
script_dir = config["script_dir"]
indir = config["input_directory"]

mito_genome = config["mito_chr"]
mito_length = str(config["mito_length"])
fasta_file = config["fasta_file"]

remove_duplicates = config["remove_duplicates"]
barcode_tag = config["barcode_tag"]
umi_barcode = config["umi_barcode"]
emit_base_qualities = config["emit_base_qualities"]

handle_overlap = config["handle_overlap"]
proper_paired = config["proper_paired"]
base_qual = str(config["base_qual"])
alignment_quality = config["alignment_quality"]
NHmax = config["NHmax"]
NMmax = config["NMmax"]
low_coverage_threshold = config["low_coverage_threshold"]

max_javamem = config["max_javamem"]

# Software paths
java = "java"
python = "python"

# Script locations
filtclip_py = join(script_dir, "bin/python/filterClipBam.py")
picardCall = f"{java} -Xmx{max_javamem} -jar {join(script_dir, 'bin/picard.jar')} MarkDuplicates"

# A Snakemake regular expression matching the bam file paths
SAMPLES, = glob_wildcards(join(outdir, ".internal/samples/{sample}.bam.txt"))
bamtxtin = ''

rule all:
    input:
        f"{mgatk_directory}/final/{name}.depthTable.txt",
        f"{mgatk_directory}/final/{name}.A.txt.gz",
        f"{mgatk_directory}/final/{name}.C.txt.gz",
        f"{mgatk_directory}/final/{name}.G.txt.gz",
        f"{mgatk_directory}/final/{name}.T.txt.gz",
        f"{mgatk_directory}/final/{name}.coverage.txt.gz",
        f"{mgatk_directory}/final/{name}.variant_stats.tsv.gz",
        f"{mgatk_directory}/final/{name}.cell_heteroplasmic_df.tsv.gz",
        f"{mgatk_directory}/final/{name}.vmr_strand_plot.png"

rule filter_bam:
    input:
        txtin = join(outdir, ".internal/samples/{sample}.bam.txt")
    output:
        temp_bam0 = join(outdir, "temp/temp_bam/{sample}.temp0.bam"),
        filtlog = join(outdir, "logs/filter/{sample}.log")
    run:
        sample = wildcards.sample
        with open(input.txtin) as f:
            input_bam = f.read().strip()
        pycall = f"{python} {filtclip_py} {input_bam} {output.filtlog} {mito_genome} {proper_paired} {NHmax} {NMmax} > {output.temp_bam0}"
        run_command(pycall)

rule sort_bam:
    input:
        temp_bam0 = join(outdir, "temp/temp_bam/{sample}.temp0.bam")
    output:
        temp_bam1 = join(outdir, "temp/temp_bam/{sample}.temp1.bam")
    run:
        pysam.sort("-o", output.temp_bam1, input.temp_bam0)
        pysam.index(output.temp_bam1)

rule remove_duplicates:
    input:
        temp_bam1 = join(outdir, "temp/temp_bam/{sample}.temp1.bam")
    output:
        output_bam = join(outdir, "temp/ready_bam/{sample}.qc.bam"),
        rmlog = join(outdir, "logs/rmdupslogs/{sample}.rmdups.log")
    run:
        if remove_duplicates == "True":
            mdc_long = f"{picardCall} I={input.temp_bam1} O={output.output_bam} M={output.rmlog} REMOVE_DUPLICATES=true ASSUME_SORTED=true VALIDATION_STRINGENCY=SILENT QUIET=true VERBOSITY=ERROR USE_JDK_DEFLATER=true USE_JDK_INFLATER=true BARCODE_TAG={umi_barcode}"
            run_command(mdc_long)
        else:
            shutil.move(input.temp_bam1, output.output_bam)
            os.remove(f"{input.temp_bam1}.bai")
        pysam.index(output.output_bam)

rule collect_genotype_counts:
    input:
        output_bam = join(outdir, "temp/ready_bam/{sample}.qc.bam")
    output:
        depth = join(outdir, "logs/depth/{sample}_depth.txt"),
        A = join(outdir, "temp/sparse_matrices/{sample}.A.txt"),
        C = join(outdir, "temp/sparse_matrices/{sample}.C.txt"),
        G = join(outdir, "temp/sparse_matrices/{sample}.G.txt"),
        T = join(outdir, "temp/sparse_matrices/{sample}.T.txt"),
        cov = join(outdir, "temp/sparse_matrices/{sample}.coverage.txt")
    run:
        sample = wildcards.sample
        barcodes_file = join(outdir, f"temp/barcode_files/{sample}.txt")
        out_pre = join(outdir, f"temp/sparse_matrices/{sample}")
        sumstats_tenx_py = join(script_dir, "bin/python/sumstatsBPtenx_overlap.py" if handle_overlap == "True" else "bin/python/sumstatsBPtenx.py")
        pycall = f"{python} {sumstats_tenx_py} {input.output_bam} {barcodes_file} {out_pre} {mito_length} {base_qual} {fasta_file} {alignment_quality} {barcode_tag}"
        run_command(pycall)

rule process_one_slice:
    input:
        txtin = join(outdir, ".internal/samples/{sample}.bam.txt")
    output:
        depth = join(outdir, "logs/depth/{sample}_depth.txt"),
        A = join(outdir, "temp/sparse_matrices/{sample}.A.txt"),
        C = join(outdir, "temp/sparse_matrices/{sample}.C.txt"),
        G = join(outdir, "temp/sparse_matrices/{sample}.G.txt"),
        T = join(outdir, "temp/sparse_matrices/{sample}.T.txt"),
        cov = join(outdir, "temp/sparse_matrices/{sample}.coverage.txt")
    run:
        sample = wildcards.sample
        barcodes_file = join(outdir, f"temp/barcode_files/{sample}.txt")
        out_pre = join(outdir, f"temp/sparse_matrices/{sample}")

        # Call the smaller rules in sequence
        snakemake.shell(f"snakemake filter_bam --cores {ncores} --config sample={sample}")
        snakemake.shell(f"snakemake sort_bam --cores {ncores} --config sample={sample}")
        snakemake.shell(f"snakemake remove_duplicates --cores {ncores} --config sample={sample}")
        snakemake.shell(f"snakemake collect_genotype_counts --cores {ncores} --config sample={sample}")

rule make_depth_table:
    input:
        depths = expand(join(mgatk_directory, "logs/depth/{sample}_depth.txt"), sample=SAMPLES)
    output:
        depthtable = join(mgatk_directory, f"final/{name}.depthTable.txt")
    run:
        with open(output.depthtable, 'w') as f:
            for file in input.depths:
                with open(file) as infile:
                    f.write(infile.read())

rule make_final_sparse_matrices:
    input:
        As = expand(join(mgatk_directory, "temp/sparse_matrices/{sample}.A.txt"), sample=SAMPLES),
        Cs = expand(join(mgatk_directory, "temp/sparse_matrices/{sample}.C.txt"), sample=SAMPLES),
        Gs = expand(join(mgatk_directory, "temp/sparse_matrices/{sample}.G.txt"), sample=SAMPLES),
        Ts = expand(join(mgatk_directory, "temp/sparse_matrices/{sample}.T.txt"), sample=SAMPLES),
        Covs = expand(join(mgatk_directory, "temp/sparse_matrices/{sample}.coverage.txt"), sample=SAMPLES)
    output:
        A = join(mgatk_directory, f"final/{name}.A.txt.gz"),
        C = join(mgatk_directory, f"final/{name}.C.txt.gz"),
        G = join(mgatk_directory, f"final/{name}.G.txt.gz"),
        T = join(mgatk_directory, f"final/{name}.T.txt.gz"),
        Cov = join(mgatk_directory, f"final/{name}.coverage.txt.gz")
    run:
        def makeSM(iterableThing, l):
            with open(join(mgatk_directory, f"final/{name}.{l}.txt"), 'w') as outfile:
                for i in iterableThing:
                    with open(i) as infile:
                        outfile.write(infile.read())
            subprocess.run(f"gzip {join(mgatk_directory, f'final/{name}.{l}.txt')}", shell=True)

        makeSM(input.As, "A")
        makeSM(input.Cs, "C")
        makeSM(input.Gs, "G")
        makeSM(input.Ts, "T")
        makeSM(input.Covs, "coverage")

rule call_variants:
    input:
        A = join(mgatk_directory, f"final/{name}.A.txt.gz"),
        C = join(mgatk_directory, f"final/{name}.C.txt.gz"),
        G = join(mgatk_directory, f"final/{name}.G.txt.gz"),
        T = join(mgatk_directory, f"final/{name}.T.txt.gz"),
        chrM_ref = join(mgatk_directory, f"final/{mito_genome}_refAllele.txt")
    output:
        variant_stats = join(mgatk_directory, f"final/{name}.variant_stats.tsv.gz"),
        heteroplasmy_df = join(mgatk_directory, f"final/{name}.cell_heteroplasmic_df.tsv.gz"),
        vmr_strand_plot = join(mgatk_directory, f"final/{name}.vmr_strand_plot.png")
    run:
        call_variant_py = join(script_dir, "bin/python/variant_calling.py")
        pycall = f"{python} {call_variant_py} {join(mgatk_directory, 'final/')} {name} {mito_length} {low_coverage_threshold} {mito_genome}"
        subprocess.run(pycall, shell=True)